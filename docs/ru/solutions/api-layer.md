# Слой api

## Семантика
Скрыть сложность взаимодействия с сервером, предоставив **удобный контракт** для всего остального кода модуля (или приложения).

Можно разбить на 2 подслоя:
- чистые функции (методы объектов) инкопсулирующие в себе транспортную логику
- реактивная обертка этих функций и оркестрация ими (Tanstack Query, SWR)

## Синтаксис

Существует 2 стратегии расположения данного слоя в проекте:
1. Единый слой на все приложение (чаще всего в shared).
2. Собственный слой api внутри каждого модуля (рядом с местом использования).

:::tip
Стратегии можно совмещать.
:::

### Единый слой

Структура папок:
```
src/
└── shared/
    └── api/
        ├── <сервис 1>/
        │   ├── client.ts
        │   ├── endpoints.ts
        │   ├── queryOptions.ts
        │   ├── queries/
        │   │   ├── useEntitiesSearchQuery.ts
        │   │   ├── useEntityDetailsQuery.ts
        │   │   └── ...
        │   ├── mutations/
        │   │   ├── useEntityCreateMutation.ts
        │   │   ├── useEntityUpdateMutation.ts
        │   │   ├── useEntityDeleteMutation.ts
        │   │   └── ...
        │   └── index.ts
        ├── <сервис 2>/
        │   ├── ...
        │   └── index.ts
        └── ...
```

Проблема - накапливается мертвый код, из-за того, что api отделен от фич.

### Слой на модуль
```
*/
└── <модуль 1>/
    └── api/
        ├── client.ts
        ├── endpoints.ts
        ├── queryOptions.ts
        ├── useEntityDetailsQuery.ts
        ├── useEntityUpdateMutation.ts
        └── index.ts
```
Причем `client.ts` можно перенести в `shared/api` переименовав в `<сервис 1>Client.ts`, чтобы в одном месте продемонстрировать все сервисы, от которых зависит frontend приложение.

## Автоматизация
Запретить любое использование fetch и axios вне `/api`